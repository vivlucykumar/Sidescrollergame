import { useState, useEffect, useRef } from 'react';
export var WebSocketStatus;
(function (WebSocketStatus) {
    WebSocketStatus["CONNECTING"] = "CONNECTING";
    WebSocketStatus["OPEN"] = "OPEN";
    WebSocketStatus["CLOSED"] = "CLOSED";
    WebSocketStatus["RECONNECTING"] = "RECONNECTING";
})(WebSocketStatus || (WebSocketStatus = {}));
/**
 * hook to manage WebSocket connections with auto-reconnect and state management.
 * @param url - WebSocket URL to connect to.
 * @param options - Configuration options for WebSocket behavior.
 * @returns WebSocketHook containing state and utility functions.
 */
export const useWebSocket = (url, { maxReconnectAttempts = 5, reconnectDelay = (attempt) => Math.min(5000, Math.pow(2, attempt) * 1000), // Default: exponential backoff
onOpen, onMessage, onError, onClose, } = {}) => {
    const [lastMessage, setLastMessage] = useState(null);
    const [status, setStatus] = useState(WebSocketStatus.CONNECTING);
    const wsRef = useRef(null);
    const reconnectAttempts = useRef(0); // Tracks reconnection attempts
    const connectWebSocket = () => {
        setStatus(WebSocketStatus.CONNECTING);
        const ws = new WebSocket(url);
        wsRef.current = ws;
        ws.onopen = () => {
            setStatus(WebSocketStatus.OPEN);
            reconnectAttempts.current = 0; // Reset reconnection attempts
            onOpen?.(); // Trigger custom callback
        };
        ws.onmessage = (event) => {
            setLastMessage(event.data);
            onMessage?.(event.data); // Trigger custom callback
        };
        ws.onerror = (error) => {
            onError?.(error); // Trigger custom callback
        };
        ws.onclose = (event) => {
            setStatus(WebSocketStatus.CLOSED);
            onClose?.(event); // Trigger custom callback
            // Attempt to reconnect if below the max attempts
            if (reconnectAttempts.current < maxReconnectAttempts) {
                reconnectAttempts.current += 1;
                setStatus(WebSocketStatus.RECONNECTING);
                setTimeout(connectWebSocket, reconnectDelay(reconnectAttempts.current));
            }
        };
    };
    const sendMessage = (message) => {
        if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
            wsRef.current.send(message);
        }
        else {
            console.warn('WebSocket is not open.');
        }
    };
    useEffect(() => {
        connectWebSocket();
        return () => {
            wsRef.current?.close();
        };
    }, [url]);
    return { lastMessage, status, sendMessage };
};
