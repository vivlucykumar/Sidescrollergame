{"version":3,"file":"Ramp.js","sources":["../../src/effects/Ramp.tsx"],"sourcesContent":["import { Uniform } from 'three'\nimport { Effect } from 'postprocessing'\nimport { wrapEffect } from '../util'\n\nconst RampShader = {\n  fragmentShader: /* glsl */ `\n    uniform int rampType;\n\n    uniform vec2 rampStart;\n    uniform vec2 rampEnd;\n\n    uniform vec4 startColor;\n    uniform vec4 endColor;\n\n    uniform float rampBias;\n    uniform float rampGain;\n\n    uniform bool rampMask;\n    uniform bool rampInvert;\n\n    float getBias(float time, float bias) {\n      return time / (((1.0 / bias) - 2.0) * (1.0 - time) + 1.0);\n    }\n\n    float getGain(float time, float gain) {\n      if (time < 0.5)\n        return getBias(time * 2.0, gain) / 2.0;\n      else\n        return getBias(time * 2.0 - 1.0, 1.0 - gain) / 2.0 + 0.5;\n    }\n\n    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {\n      vec2 centerPixel = uv * resolution;\n      vec2 startPixel = rampStart * resolution;\n      vec2 endPixel = rampEnd * resolution;\n\n      float rampAlpha;\n\n      if (rampType == 1) {\n        vec2 fuv = centerPixel / resolution.y;\n        vec2 suv = startPixel / resolution.y;\n        vec2 euv = endPixel / resolution.y;\n\n        float radius = length(suv - euv);\n        float falloff = length(fuv - suv);\n        rampAlpha = smoothstep(0.0, radius, falloff);\n      } else {\n        float radius = length(startPixel - endPixel);\n        vec2 direction = normalize(vec2(endPixel.x - startPixel.x, -(startPixel.y - endPixel.y)));\n\n        float fade = dot(centerPixel - startPixel, direction);\n        if (rampType == 2) fade = abs(fade);\n\n        rampAlpha = smoothstep(0.0, 1.0, fade / radius);\n      }\n\n      rampAlpha = abs((rampInvert ? 1.0 : 0.0) - getBias(rampAlpha, rampBias) * getGain(rampAlpha, rampGain));\n\n      if (rampMask) {\n        vec4 inputBuff = texture2D(inputBuffer, uv);\n        outputColor = mix(inputBuff, inputColor, rampAlpha);\n      } else {\n        outputColor = mix(startColor, endColor, rampAlpha);\n      }\n    }\n  `,\n}\n\nexport enum RampType {\n  Linear,\n  Radial,\n  MirroredLinear,\n}\n\nexport class RampEffect extends Effect {\n  constructor({\n    /**\n     * Type of ramp gradient.\n     */\n    rampType = RampType.Linear,\n    /**\n     * Starting point of the ramp gradient in normalized coordinates.\n     *\n     * Ranges from `[0 - 1]` as `[x, y]`. Default is `[0.5, 0.5]`.\n     */\n    rampStart = [0.5, 0.5],\n    /**\n     * Ending point of the ramp gradient in normalized coordinates.\n     *\n     * Ranges from `[0 - 1]` as `[x, y]`. Default is `[1, 1]`\n     */\n    rampEnd = [1, 1],\n    /**\n     * Color at the starting point of the gradient.\n     *\n     * Default is black: `[0, 0, 0, 1]`\n     */\n    startColor = [0, 0, 0, 1],\n    /**\n     * Color at the ending point of the gradient.\n     *\n     * Default is white: `[1, 1, 1, 1]`\n     */\n    endColor = [1, 1, 1, 1],\n    /**\n     * Bias for the interpolation curve when both bias and gain are 0.5.\n     *\n     * Ranges from `[0 - 1]`. Default is `0.5`.\n     */\n    rampBias = 0.5,\n    /**\n     * Gain for the interpolation curve when both bias and gain are 0.5.\n     *\n     * Ranges from `[0 - 1]`. Default is `0.5`.\n     */\n    rampGain = 0.5,\n    /**\n     * When enabled, the ramp gradient is used as an effect mask, and colors are ignored.\n     *\n     * Default is `false`.\n     */\n    rampMask = false,\n    /**\n     * Controls whether the ramp gradient is inverted.\n     *\n     * When disabled, rampStart is transparent and rampEnd is opaque.\n     *\n     * Default is `false`.\n     */\n    rampInvert = false,\n    ...params\n  } = {}) {\n    super('RampEffect', RampShader.fragmentShader, {\n      ...params,\n      uniforms: new Map<string, Uniform>([\n        ['rampType', new Uniform(rampType)],\n        ['rampStart', new Uniform(rampStart)],\n        ['rampEnd', new Uniform(rampEnd)],\n        ['startColor', new Uniform(startColor)],\n        ['endColor', new Uniform(endColor)],\n        ['rampBias', new Uniform(rampBias)],\n        ['rampGain', new Uniform(rampGain)],\n        ['rampMask', new Uniform(rampMask)],\n        ['rampInvert', new Uniform(rampInvert)],\n      ]),\n    })\n  }\n}\n\nexport const Ramp = /* @__PURE__ */ wrapEffect(RampEffect)\n"],"names":["RampType"],"mappings":";;;AAIA,MAAM,aAAa;AAAA,EACjB;AAAA;AAAA,IAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6D7B;AAEY,IAAA,6BAAAA,cAAL;AACLA,YAAA,UAAA,QAAA,IAAA,CAAA,IAAA;AACAA,YAAA,UAAA,QAAA,IAAA,CAAA,IAAA;AACAA,YAAA,UAAA,gBAAA,IAAA,CAAA,IAAA;AAHUA,SAAAA;AAAA,GAAA,YAAA,CAAA,CAAA;AAML,MAAM,mBAAmB,OAAO;AAAA,EACrC,YAAY;AAAA;AAAA;AAAA;AAAA,IAIV,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMX,YAAY,CAAC,KAAK,GAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMrB,UAAU,CAAC,GAAG,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMf,aAAa,CAAC,GAAG,GAAG,GAAG,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMxB,WAAW,CAAC,GAAG,GAAG,GAAG,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMtB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMX,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMX,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQX,aAAa;AAAA,IACb,GAAG;AAAA,EACL,IAAI,IAAI;AACA,UAAA,cAAc,WAAW,gBAAgB;AAAA,MAC7C,GAAG;AAAA,MACH,8BAAc,IAAqB;AAAA,QACjC,CAAC,YAAY,IAAI,QAAQ,QAAQ,CAAC;AAAA,QAClC,CAAC,aAAa,IAAI,QAAQ,SAAS,CAAC;AAAA,QACpC,CAAC,WAAW,IAAI,QAAQ,OAAO,CAAC;AAAA,QAChC,CAAC,cAAc,IAAI,QAAQ,UAAU,CAAC;AAAA,QACtC,CAAC,YAAY,IAAI,QAAQ,QAAQ,CAAC;AAAA,QAClC,CAAC,YAAY,IAAI,QAAQ,QAAQ,CAAC;AAAA,QAClC,CAAC,YAAY,IAAI,QAAQ,QAAQ,CAAC;AAAA,QAClC,CAAC,YAAY,IAAI,QAAQ,QAAQ,CAAC;AAAA,QAClC,CAAC,cAAc,IAAI,QAAQ,UAAU,CAAC;AAAA,MAAA,CACvC;AAAA,IAAA,CACF;AAAA,EACH;AACF;AAEa,MAAA,kCAAkC,UAAU;"}